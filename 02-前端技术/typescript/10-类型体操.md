# 类型体操

## 1. 基础工具类型实现

```ts
// 实现 Partial
type MyPartial<T> = {
    [P in keyof T]?: T[P];
};

// 实现 Required
type MyRequired<T> = {
    [P in keyof T]-?: T[P];
};

// 实现 Readonly
type MyReadonly<T> = {
    readonly [P in keyof T]: T[P];
};

// 实现 Record
type MyRecord<K extends keyof any, T> = {
    [P in K]: T;
};
```

## 2. 条件类型与 infer

```ts
// 获取函数返回类型
type MyReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R
    ? R
    : never;

// 获取函数参数类型
type MyParameters<T extends (...args: any) => any> = T extends (...args: infer P) => any
    ? P
    : never;

// 获取构造函数实例类型
type MyInstanceType<T extends abstract new (...args: any) => any> = T extends abstract new (
    ...args: any
) => infer R
    ? R
    : any;

// 获取构造函数参数类型
type MyConstructorParameters<T extends abstract new (...args: any) => any> =
    T extends abstract new (...args: infer P) => any ? P : never;
```

## 3. 递归类型

```ts
// 深度 Partial
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

// 深度 Readonly
type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

// 获取嵌套对象的所有路径
type Paths<T> = T extends object
    ? {
          [K in keyof T]: `${K & string}` | `${K & string}.${Paths<T[K]> & string}`;
      }[keyof T]
    : never;

type Example = {
    a: {
        b: {
            c: number;
        };
        d: string;
    };
    e: boolean;
};

type ExamplePaths = Paths<Example>; // "a" | "e" | "a.b" | "a.d" | "a.b.c"
```

## 4. 模板字面量类型

```ts
// 首字母大写
type Capitalize<S extends string> = S extends `${infer First}${infer Rest}`
    ? `${Uppercase<First>}${Rest}`
    : S;

// 字符串替换
type Replace<S extends string, From extends string, To extends string> = From extends ""
    ? S
    : S extends `${infer L}${From}${infer R}`
    ? `${L}${To}${R}`
    : S;

// 字符串分割
type Split<
    S extends string,
    Delimiter extends string
> = S extends `${infer Head}${Delimiter}${infer Tail}` ? [Head, ...Split<Tail, Delimiter>] : [S];
```

## 5. 联合类型操作

```ts
// 联合类型转交叉类型
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void
    ? I
    : never;

// 联合类型转元组（简化版）
type UnionToTuple<T> = UnionToIntersection<T extends any ? () => T : never> extends () => infer R
    ? [...UnionToTuple<Exclude<T, R>>, R]
    : [];

// 获取联合类型的最后一个成员
type LastOfUnion<U> = UnionToIntersection<U extends any ? () => U : never> extends () => infer R
    ? R
    : never;
```

## 6. 实用工具类型

```ts
// 获取对象的可选键
type OptionalKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? K : never;
}[keyof T];

// 获取对象的必需键
type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];

// 反转键值对
type Flip<T extends Record<keyof any, any>> = {
    [K in keyof T as T[K]]: K;
};

// 严格的 Omit（确保只省略存在的键）
type StrictOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
```

## 7. 挑战性类型

```ts
// 柯里化函数的类型
type Curry<F extends (...args: any[]) => any> = F extends (...args: infer A) => infer R
    ? A extends [infer First, ...infer Rest]
        ? (arg: First) => Curry<(...args: Rest) => R>
        : R
    : never;

// 递归柯里化（支持多参数）
type Curried<F extends (...args: any[]) => any> = F extends (...args: infer Args) => infer R
    ? Args extends [infer A, ...infer B]
        ? B extends []
            ? (arg: A) => R
            : (arg: A) => Curried<(...args: B) => R>
        : () => R
    : never;

// 元组转联合
type TupleToUnion<T extends any[]> = T[number];

// 联合类型转元组（保持顺序）
type UnionToOrderedTuple<T, U = T> = [T] extends [never]
    ? []
    : U extends U
    ? [U, ...UnionToOrderedTuple<Exclude<T, U>>]
    : [];
```

## 8. 实战示例

```ts
// API 响应类型安全包装
type ApiResponse<T> =
    | { status: "success"; data: T; timestamp: number }
    | { status: "error"; message: string; code: number; timestamp: number }
    | { status: "loading" };

// 条件渲染 Props
type ConditionalProps<T extends boolean> = T extends true
    ? { primary: boolean; size: "large" | "small" }
    : { secondary?: boolean; size?: "medium" };

// 表单验证类型
type Validator<T> = {
    [K in keyof T]?: (value: T[K]) => boolean | string;
};

type FormValues = {
    email: string;
    age: number;
    agree: boolean;
};

type FormValidators = Validator<FormValues>;
// 等价于：
// type FormValidators = {
//   email?: (value: string) => boolean | string;
//   age?: (value: number) => boolean | string;
//   agree?: (value: boolean) => boolean | string;
// };
```

## 9. 类型安全的事件系统

```ts
type EventMap = {
    click: { x: number; y: number };
    change: { value: string };
    submit: { data: Record<string, any> };
};

type EventHandler<T> = (event: T) => void;

type EventSystem = {
    on<K extends keyof EventMap>(event: K, handler: EventHandler<EventMap[K]>): void;
    emit<K extends keyof EventMap>(event: K, payload: EventMap[K]): void;
};
```
