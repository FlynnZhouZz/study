# 控制流与错误处理

## 控制流语句

### 1. 条件语句

#### `if...else`

```js
// 基本形式
if (condition) {
    // 条件为真时执行
} else if (anotherCondition) {
    // 另一个条件为真时执行
} else {
    // 以上条件都不为真时执行
}

// 示例
let score = 85;

if (score >= 90) {
    console.log("优秀");
} else if (score >= 80) {
    console.log("良好");
} else if (score >= 60) {
    console.log("及格");
} else {
    console.log("不及格");
}

// 三元运算符
let result = score >= 60 ? "及格" : "不及格";
let grade = score >= 90 ? "A" : score >= 80 ? "B" : "C";
```

#### `switch`

```js
switch (expression) {
    case value1:
        // 匹配 value1 时执行
        break;
    case value2:
        // 匹配 value2 时执行
        break;
    default:
    // 没有匹配时执行
}

// 示例
let day = 3;
let dayName;

switch (day) {
    case 1:
        dayName = "星期一";
        break;
    case 2:
        dayName = "星期二";
        break;
    case 3:
        dayName = "星期三";
        break;
    case 4:
        dayName = "星期四";
        break;
    case 5:
        dayName = "星期五";
        break;
    case 6:
        dayName = "星期六";
        break;
    case 7:
        dayName = "星期日";
        break;
    default:
        dayName = "无效的日期";
}

// 多个 case 共享代码
let month = 2;
let season;

switch (month) {
    case 12:
    case 1:
    case 2:
        season = "冬季";
        break;
    case 3:
    case 4:
    case 5:
        season = "春季";
        break;
    case 6:
    case 7:
    case 8:
        season = "夏季";
        break;
    case 9:
    case 10:
    case 11:
        season = "秋季";
        break;
    default:
        season = "无效的月份";
}
```

## 错误处理

### 1. `try...catch...finally`

```js
// 基本语法
try {
    // 可能会抛出错误的代码
    riskyOperation();
} catch (error) {
    // 错误处理
    console.error("发生错误:", error.message);
} finally {
    // 无论是否发生错误都会执行
    console.log("清理操作");
}

// 示例
function divide(a, b) {
    try {
        if (b === 0) {
            throw new Error("除数不能为零");
        }
        return a / b;
    } catch (error) {
        console.error("计算错误:", error.message);
        return NaN;
    } finally {
        console.log("除法运算完成");
    }
}

// 多个 catch 块（ES2019+）
try {
    // 可能抛出多种类型的错误
} catch (error) {
    if (error instanceof TypeError) {
        // 处理类型错误
    } else if (error instanceof RangeError) {
        // 处理范围错误
    } else if (error instanceof EvalError) {
        // 处理 eval 错误
    } else {
        // 处理其他错误
    }
}
```

### 2. Error 类型

```js
// 内置 Error 类型
try {
    throw new Error("普通错误");
} catch (e) {
    console.log(e.name); // "Error"
    console.log(e.message); // "普通错误"
    console.log(e.stack); // 堆栈跟踪
}

// 特定错误类型
try {
    throw new SyntaxError("语法错误");
    throw new TypeError("类型错误");
    throw new RangeError("范围错误");
    throw new ReferenceError("引用错误");
    throw new URIError("URI错误");
    throw new EvalError("Eval错误");
} catch (error) {
    console.error(error.name + ": " + error.message);
}

// 自定义错误
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = "ValidationError";
        this.field = field;
        this.timestamp = new Date().toISOString();
    }
}

try {
    throw new ValidationError("无效的输入", "username");
} catch (error) {
    if (error instanceof ValidationError) {
        console.error(`${error.name}: ${error.message} (字段: ${error.field})`);
    }
}
```

### 3. `throw` 语句

```js
// 抛出字符串（不推荐）
throw "发生错误";

// 抛出数字（不推荐）
throw 404;

// 抛出对象（不推荐）
throw { message: "错误", code: 500 };

// 抛出 Error 对象（推荐）
throw new Error("错误描述");

// 条件抛出
function getUser(id) {
    if (!id || id <= 0) {
        throw new Error("无效的用户ID");
    }
    // 获取用户逻辑...
}

// 在表达式中使用 throw
function getDefault(value) {
    return value || throw new Error("值不能为空");
}
```

## 高级控制流模式

### 1. 短路求值

```js
// 逻辑与 (&&) 短路
let user = null;
let username = user && user.name; // 不会报错，返回 null

// 逻辑或 (||) 短路
let config = userConfig || defaultConfig;

// 空值合并运算符 ?? (ES2020)
let value = null ?? "default"; // "default"
let value2 = 0 ?? "default"; // 0 (与 || 不同)

// 可选链操作符 ?. (ES2020)
let street = user?.address?.street; // 不会报错
```

### 2. 条件链式调用

```js
// 传统方式
let result;
if (obj) {
    if (obj.method1) {
        result = obj.method1();
        if (result && result.method2) {
            return result.method2();
        }
    }
}

// 链式调用
let result = obj?.method1?.()?.method2?.();
```

### 3. 使用函数式方法

```js
// 替代 for 循环
const numbers = [1, 2, 3, 4, 5];

// 遍历
numbers.forEach(num => console.log(num));

// 过滤
const even = numbers.filter(num => num % 2 === 0);

// 映射
const doubled = numbers.map(num => num * 2);

// 查找
const firstEven = numbers.find(num => num % 2 === 0);

// 检查
const allPositive = numbers.every(num => num > 0);
const hasNegative = numbers.some(num => num < 0);

// 归约
const sum = numbers.reduce((total, num) => total + num, 0);
```

### 4. 生成器和迭代器

```js
// 生成器函数
function* numberGenerator() {
    let num = 1;
    while (true) {
        yield num++;
    }
}

const gen = numberGenerator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2

// 使用生成器控制流程
function* taskRunner() {
    console.log("开始任务1");
    yield;
    console.log("开始任务2");
    yield;
    console.log("所有任务完成");
}

const runner = taskRunner();
runner.next(); // 开始任务1
runner.next(); // 开始任务2
runner.next(); // 所有任务完成
```

## 错误处理最佳实践

### 1. 防御性编程

```js
// 参数验证
function processData(data) {
    if (!data || typeof data !== "object") {
        throw new TypeError("参数必须是对象");
    }

    if (!Array.isArray(data.items)) {
        throw new TypeError("items 必须是数组");
    }

    // 安全地处理数据
    return data.items.map(item => ({
        ...item,
        processed: true,
    }));
}

// 使用默认值
function createUser(options = {}) {
    const defaults = {
        name: "匿名",
        age: 18,
        email: "",
    };

    return { ...defaults, ...options };
}
```

### 2. 异步错误处理

```js
// Promise 错误处理
fetch("https://api.example.com/data")
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status}`);
        }
        return response.json();
    })
    .then(data => console.log(data))
    .catch(error => console.error("请求失败:", error));

// async/await 错误处理
async function fetchData() {
    try {
        const response = await fetch("https://api.example.com/data");
        if (!response.ok) {
            throw new Error(`HTTP错误: ${response.status}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error("获取数据失败:", error);
        // 返回默认值或重新抛出
        throw error; // 或 return defaultValue;
    }
}

// 并行异步错误处理
async function fetchMultiple() {
    try {
        const [data1, data2] = await Promise.all([fetchData1(), fetchData2()]);
        return { data1, data2 };
    } catch (error) {
        // 处理第一个失败的情况
        console.error("并行请求失败:", error);
    }
}
```

### 3. 全局错误处理

```js
// 全局错误事件
window.addEventListener("error", function (event) {
    console.error("全局错误:", event.error);
    // 发送到错误监控服务
    sendToErrorTracking(event.error);
    // 阻止默认错误处理
    event.preventDefault();
});

// 未处理的 Promise 拒绝
window.addEventListener("unhandledrejection", function (event) {
    console.error("未处理的 Promise 拒绝:", event.reason);
    event.preventDefault();
});

// Node.js 全局错误处理
process.on("uncaughtException", error => {
    console.error("未捕获的异常:", error);
    // 记录错误并优雅退出
    process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
    console.error("未处理的 Promise 拒绝:", reason);
});
```

### 4. 错误恢复策略

```js
// 重试机制
async function fetchWithRetry(url, maxRetries = 3) {
    for (let i = 0; i <= maxRetries; i++) {
        try {
            const response = await fetch(url);
            return await response.json();
        } catch (error) {
            if (i === maxRetries) {
                throw error;
            }
            console.log(`重试 ${i + 1}/${maxRetries}`);
            await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i))); // 指数退避
        }
    }
}

// 降级策略
async function getData() {
    try {
        return await fetchFromPrimarySource();
    } catch (error) {
        console.warn("主数据源失败，使用备用源");
        try {
            return await fetchFromFallbackSource();
        } catch (fallbackError) {
            console.error("所有数据源都失败");
            return getCachedData(); // 返回缓存数据
        }
    }
}
```

## 调试技巧

### 1. 控制台方法

```js
// 不同级别的日志
console.log("普通日志");
console.info("信息日志");
console.warn("警告日志");
console.error("错误日志");
console.debug("调试日志");

// 分组日志
console.group("用户信息");
console.log("姓名: 张三");
console.log("年龄: 25");
console.groupEnd();

// 表格显示
console.table([
    { name: "张三", age: 25 },
    { name: "李四", age: 30 },
]);

// 断言
console.assert(1 === 2, "1 不等于 2");

// 跟踪调用栈
console.trace("当前位置");

// 性能测量
console.time("操作耗时");
// 执行操作...
console.timeEnd("操作耗时");
```

### 2. debugger 语句

```js
function complexOperation() {
    let result = 0;
    debugger; // 执行到这里会暂停，可以检查变量

    for (let i = 0; i < 10; i++) {
        result += i;
    }

    return result;
}
```

## 代码质量工具

### 1. ESLint 规则

```js
// .eslintrc.js 中的控制流相关规则
module.exports = {
    rules: {
        "no-constant-condition": "error", // 禁止常量条件
        "no-unreachable": "error", // 禁止不可达代码
        "no-duplicate-case": "error", // 禁止重复 case
        "default-case": "warn", // 要求 switch 有 default
        "no-fallthrough": "error", // 禁止 case 穿透
        "no-labels": "warn", // 避免使用标签
        "no-unused-expressions": "error", // 禁止未使用的表达式
        "no-console": "warn", // 避免使用 console
        "consistent-return": "error", // 要求一致的返回值
        curly: ["error", "all"], // 要求使用大括号
        eqeqeq: ["error", "always"], // 要求使用 === 和 !==
        "no-throw-literal": "error", // 只能抛出 Error 对象
        "no-unsafe-finally": "error", // finally 中避免控制转移
    },
};
```
