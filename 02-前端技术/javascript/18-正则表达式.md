# æ­£åˆ™è¡¨è¾¾å¼

## æ­£åˆ™è¡¨è¾¾å¼åŸºç¡€

### 1. åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼

```js
// 1. å­—é¢é‡è¯­æ³•ï¼ˆæ¨èï¼‰
const regex1 = /pattern/;
const regex2 = /pattern/flags;

// 2. æ„é€ å‡½æ•°
const regex3 = new RegExp('pattern');
const regex4 = new RegExp('pattern', 'flags');
const regex5 = new RegExp(/pattern/, 'flags'); // ES6+

// 3. åŠ¨æ€åˆ›å»ºï¼ˆä½¿ç”¨æ„é€ å‡½æ•°ï¼‰
const word = 'hello';
const regex6 = new RegExp(word, 'i');

// 4. è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦
const regex7 = /\.js$/;          // åŒ¹é…ä»¥ .js ç»“å°¾
const regex8 = /\[test\]/;       // åŒ¹é… [test]

// 5. ä½¿ç”¨å­—ç¬¦ä¸²åˆ›å»ºæ—¶çš„åŒé‡è½¬ä¹‰
const literal = /\d+/;           // åŒ¹é…ä¸€ä¸ªæˆ–å¤šä¸ªæ•°å­—
const constructor = new RegExp('\\d+'); // éœ€è¦åŒé‡è½¬ä¹‰
```

### 2. åŒ¹é…æ¨¡å¼æ ‡å¿—ï¼ˆflagsï¼‰

```js
// i - ä¸åŒºåˆ†å¤§å°å†™
const caseInsensitive = /hello/i;
console.log(caseInsensitive.test("Hello")); // true
console.log(caseInsensitive.test("HELLO")); // true

// g - å…¨å±€åŒ¹é…ï¼ˆæŸ¥æ‰¾æ‰€æœ‰åŒ¹é…ï¼‰
const global = /a/g;
const str = "abc abc";
console.log(str.match(global)); // ['a', 'a']

// m - å¤šè¡Œæ¨¡å¼
const multiline = /^test/m;
const multilineStr = "first line\ntest line";
console.log(multiline.test(multilineStr)); // true

// s - dotAllæ¨¡å¼ï¼ˆ.åŒ¹é…åŒ…æ‹¬æ¢è¡Œç¬¦çš„æ‰€æœ‰å­—ç¬¦ï¼‰
const dotAll = /test.+end/s;
const multilineStr2 = "test line1\nline2 end";
console.log(dotAll.test(multilineStr2)); // true

// u - Unicodeæ¨¡å¼
const unicode = /\u{1F60A}/u; // åŒ¹é…ğŸ˜Š
console.log(unicode.test("ğŸ˜Š")); // true

// y - ç²˜æ€§åŒ¹é…ï¼ˆä»ä¸Šæ¬¡åŒ¹é…ç»“æŸä½ç½®å¼€å§‹ï¼‰
const sticky = /a/y;
sticky.lastIndex = 1;
console.log(sticky.test("aba")); // trueï¼ˆä»ç´¢å¼•1å¼€å§‹åŒ¹é…ï¼‰
console.log(sticky.lastIndex); // 2

// d - åŒ…å«åŒ¹é…ç´¢å¼•ä¿¡æ¯ï¼ˆES2022+ï¼‰
const hasIndices = /test/d;
const result = hasIndices.exec("test string");
console.log(result.indices); // [[0, 4]]
```

### 3. åŸºç¡€åŒ¹é…

```js
// æµ‹è¯•æ˜¯å¦å­˜åœ¨åŒ¹é…
const regex = /hello/;
console.log(regex.test("hello world")); // true
console.log(regex.test("goodbye")); // false

// è·å–åŒ¹é…ç»“æœ
const str = "hello world hello";
const regex2 = /hello/;
console.log(regex2.exec(str)); // ["hello", index: 0, input: "hello world hello"]

// å­—ç¬¦ä¸²æ–¹æ³•
const testStr = "JavaScript is fun!";

console.log(testStr.match(/Java/)); // ["Java"]
console.log(testStr.match(/java/i)); // ["Java"]ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
console.log(testStr.match(/java/gi)); // ["Java"]ï¼ˆå…¨å±€+ä¸åŒºåˆ†å¤§å°å†™ï¼‰
console.log(testStr.search(/fun/)); // 14ï¼ˆåŒ¹é…ä½ç½®ï¼‰
console.log(testStr.replace(/fun/, "awesome")); // "JavaScript is awesome!"
console.log(testStr.split(/\s+/)); // ["JavaScript", "is", "fun!"]
```

## å­—ç¬¦ä¸å­—ç¬¦ç±»

### 1. ç‰¹æ®Šå­—ç¬¦

```js
// å­—é¢é‡å­—ç¬¦
const literal = /hello/; // åŒ¹é… "hello"

// å…ƒå­—ç¬¦ï¼ˆéœ€è¦è½¬ä¹‰ï¼‰
// . \ + * ? ^ $ { } [ ] ( ) | /

// ç‚¹å· . - åŒ¹é…é™¤æ¢è¡Œç¬¦å¤–çš„ä»»æ„å•ä¸ªå­—ç¬¦
const dot = /h.llo/;
console.log(dot.test("hello")); // true
console.log(dot.test("hallo")); // true
console.log(dot.test("h\nllo")); // false

// åœ¨ dotAll æ¨¡å¼ä¸‹åŒ¹é…æ‰€æœ‰å­—ç¬¦
const dotAll = /h.llo/s;
console.log(dotAll.test("h\nllo")); // true
```

### 2. å­—ç¬¦ç±»

```js
// ç®€å•å­—ç¬¦ç±» []
const vowel = /[aeiou]/; // åŒ¹é…ä»»æ„å…ƒéŸ³å­—æ¯
console.log(vowel.test("hello")); // true
console.log(vowel.test("xyz")); // false

// èŒƒå›´å­—ç¬¦ç±»
const lowercase = /[a-z]/; // åŒ¹é…ä»»æ„å°å†™å­—æ¯
const uppercase = /[A-Z]/; // åŒ¹é…ä»»æ„å¤§å†™å­—æ¯
const digits = /[0-9]/; // åŒ¹é…ä»»æ„æ•°å­—
const alphanumeric = /[a-zA-Z0-9]/; // åŒ¹é…å­—æ¯æ•°å­—

// æ’é™¤å­—ç¬¦ç±» [^]
const notVowel = /[^aeiou]/; // åŒ¹é…éå…ƒéŸ³å­—ç¬¦
console.log(notVowel.test("a")); // false
console.log(notVowel.test("b")); // true

// ç»„åˆå­—ç¬¦ç±»
const hex = /[0-9a-fA-F]/; // åŒ¹é…åå…­è¿›åˆ¶å­—ç¬¦
const identifier = /[a-zA-Z_$][a-zA-Z0-9_$]*/; // JavaScriptæ ‡è¯†ç¬¦

// Unicodeå­—ç¬¦ç±»
const chinese = /[\u4e00-\u9fff]/; // åŒ¹é…ä¸­æ–‡å­—ç¬¦
const emoji = /\p{Emoji}/u; // åŒ¹é…è¡¨æƒ…ç¬¦å·ï¼ˆES2018+ï¼‰
const letter = /\p{Letter}/u; // åŒ¹é…ä»»æ„å­—æ¯
```

### 3. é¢„å®šä¹‰å­—ç¬¦ç±»

```js
// \d - æ•°å­—ï¼ˆç­‰ä»·äº [0-9]ï¼‰
const digit = /\d/;
console.log(digit.test("123")); // true
console.log(digit.test("abc")); // false

// \D - éæ•°å­—ï¼ˆç­‰ä»·äº [^0-9]ï¼‰
const notDigit = /\D/;
console.log(notDigit.test("123")); // false
console.log(notDigit.test("abc")); // true

// \w - å•è¯å­—ç¬¦ï¼ˆç­‰ä»·äº [a-zA-Z0-9_]ï¼‰
const wordChar = /\w/;
console.log(wordChar.test("a")); // true
console.log(wordChar.test("_")); // true
console.log(wordChar.test("@")); // false

// \W - éå•è¯å­—ç¬¦
const notWordChar = /\W/;
console.log(notWordChar.test("a")); // false
console.log(notWordChar.test("@")); // true

// \s - ç©ºç™½å­—ç¬¦ï¼ˆç©ºæ ¼ã€åˆ¶è¡¨ç¬¦ã€æ¢è¡Œç¬¦ç­‰ï¼‰
const whitespace = /\s/;
console.log(whitespace.test(" ")); // true
console.log(whitespace.test("\t")); // true
console.log(whitespace.test("a")); // false

// \S - éç©ºç™½å­—ç¬¦
const notWhitespace = /\S/;
console.log(notWhitespace.test(" ")); // false
console.log(notWhitespace.test("a")); // true

// . - é™¤æ¢è¡Œç¬¦å¤–çš„ä»»æ„å­—ç¬¦
const anyChar = /./;
console.log(anyChar.test("a")); // true
console.log(anyChar.test("\n")); // falseï¼ˆé™¤éä½¿ç”¨sæ ‡å¿—ï¼‰

// \b - å•è¯è¾¹ç•Œ
const wordBoundary = /\bword\b/;
console.log(wordBoundary.test("hello world")); // true
console.log(wordBoundary.test("hello worldview")); // false

// \B - éå•è¯è¾¹ç•Œ
const notWordBoundary = /\Bword\B/;
console.log(notWordBoundary.test("hello worldview")); // true

// \0 - ç©ºå­—ç¬¦
// \n - æ¢è¡Œç¬¦
// \r - å›è½¦ç¬¦
// \t - åˆ¶è¡¨ç¬¦
// \v - å‚ç›´åˆ¶è¡¨ç¬¦
// \f - æ¢é¡µç¬¦
```

## é‡è¯ä¸åˆ†ç»„

### 1. é‡è¯

```js
// * - 0æ¬¡æˆ–å¤šæ¬¡
const zeroOrMore = /ab*c/;
console.log(zeroOrMore.test("ac")); // true
console.log(zeroOrMore.test("abc")); // true
console.log(zeroOrMore.test("abbbc")); // true

// + - 1æ¬¡æˆ–å¤šæ¬¡
const oneOrMore = /ab+c/;
console.log(oneOrMore.test("ac")); // false
console.log(oneOrMore.test("abc")); // true
console.log(oneOrMore.test("abbbc")); // true

// ? - 0æ¬¡æˆ–1æ¬¡
const zeroOrOne = /ab?c/;
console.log(zeroOrOne.test("ac")); // true
console.log(zeroOrOne.test("abc")); // true
console.log(zeroOrOne.test("abbbc")); // false

// {n} - æ°å¥½næ¬¡
const exactlyThree = /a{3}/;
console.log(exactlyThree.test("aaa")); // true
console.log(exactlyThree.test("aa")); // false
console.log(exactlyThree.test("aaaa")); // trueï¼ˆåŒ¹é…å‰3ä¸ªaï¼‰

// {n,} - è‡³å°‘næ¬¡
const atLeastTwo = /a{2,}/;
console.log(atLeastTwo.test("a")); // false
console.log(atLeastTwo.test("aa")); // true
console.log(atLeastTwo.test("aaaa")); // true

// {n,m} - nåˆ°mæ¬¡
const betweenTwoAndFour = /a{2,4}/;
console.log(betweenTwoAndFour.test("a")); // false
console.log(betweenTwoAndFour.test("aa")); // true
console.log(betweenTwoAndFour.test("aaaa")); // true
console.log(betweenTwoAndFour.test("aaaaa")); // trueï¼ˆåŒ¹é…å‰4ä¸ªaï¼‰

// è´ªå©ªåŒ¹é…ï¼ˆé»˜è®¤ï¼‰
const greedy = /a+/;
console.log("aaa".match(greedy)); // ["aaa"]

// æƒ°æ€§åŒ¹é…ï¼ˆéè´ªå©ªï¼‰
const lazy = /a+?/;
console.log("aaa".match(lazy)); // ["a"]

// ç‹¬å åŒ¹é…ï¼ˆé˜²æ­¢å›æº¯ï¼‰
const possessive = /a++/; // JavaScriptä¸æ”¯æŒç‹¬å é‡è¯
```

### 2. åˆ†ç»„

```js
// æ•è·åˆ†ç»„ ()
const capture = /(\d{4})-(\d{2})-(\d{2})/;
const date = "2024-01-15";
const match = date.match(capture);

console.log(match[0]); // "2024-01-15"ï¼ˆå®Œæ•´åŒ¹é…ï¼‰
console.log(match[1]); // "2024"ï¼ˆç¬¬ä¸€ä¸ªåˆ†ç»„ï¼‰
console.log(match[2]); // "01"ï¼ˆç¬¬äºŒä¸ªåˆ†ç»„ï¼‰
console.log(match[3]); // "15"ï¼ˆç¬¬ä¸‰ä¸ªåˆ†ç»„ï¼‰

// å‘½åæ•è·åˆ†ç»„ ?<name>ï¼ˆES2018+ï¼‰
const namedCapture = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const namedMatch = date.match(namedCapture);

console.log(namedMatch.groups.year); // "2024"
console.log(namedMatch.groups.month); // "01"
console.log(namedMatch.groups.day); // "15"

// éæ•è·åˆ†ç»„ ?:
const nonCapture = /(?:Mr|Ms|Mrs)\. (\w+)/;
const nameMatch = "Mr. Smith".match(nonCapture);
console.log(nameMatch[0]); // "Mr. Smith"
console.log(nameMatch[1]); // "Smith"
console.log(nameMatch[2]); // undefinedï¼ˆ?:ä¸æ•è·ï¼‰

// åˆ†ç»„å¼•ç”¨
const duplicateWords = /\b(\w+)\s+\1\b/;
console.log(duplicateWords.test("hello hello")); // true
console.log(duplicateWords.test("hello world")); // false

// å‘½ååˆ†ç»„å¼•ç”¨ \k<name>
const namedDuplicate = /\b(?<word>\w+)\s+\k<word>\b/;
console.log(namedDuplicate.test("test test")); // true

// åœ¨æ›¿æ¢ä¸­ä½¿ç”¨åˆ†ç»„
const reformatDate = "2024-01-15".replace(/(\d{4})-(\d{2})-(\d{2})/, "$2/$3/$1");
console.log(reformatDate); // "01/15/2024"

// åœ¨æ›¿æ¢ä¸­ä½¿ç”¨å‘½ååˆ†ç»„
const reformatNamed = "2024-01-15".replace(
    /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/,
    "$<month>/$<day>/$<year>"
);
console.log(reformatNamed); // "01/15/2024"
```

### 3. é€‰æ‹©ä¸æ–­è¨€

```js
// é€‰æ‹©ç¬¦ |
const or = /cat|dog|bird/;
console.log(or.test("I have a cat")); // true
console.log(or.test("I have a dog")); // true
console.log(or.test("I have a fish")); // false

// åˆ†ç»„ä¸­çš„é€‰æ‹©
const animal = /(cat|dog|bird)s?/;
console.log(animal.test("cats")); // true
console.log(animal.test("dog")); // true

// æ­£å‘å…ˆè¡Œæ–­è¨€ ?=ï¼ˆåé¢æ˜¯...ï¼‰
const followedBy = /\d+(?= dollars)/;
console.log(followedBy.exec("100 dollars")); // ["100"]
console.log(followedBy.exec("100 yen")); // null

// è´Ÿå‘å…ˆè¡Œæ–­è¨€ ?!ï¼ˆåé¢ä¸æ˜¯...ï¼‰
const notFollowedBy = /\d+(?! dollars)/;
console.log(notFollowedBy.exec("100 dollars")); // null
console.log(notFollowedBy.exec("100 yen")); // ["100"]

// æ­£å‘åè¡Œæ–­è¨€ ?<=ï¼ˆå‰é¢æ˜¯...ï¼‰
const precededBy = /(?<=\$)\d+/;
console.log(precededBy.exec("Price: $100")); // ["100"]
console.log(precededBy.exec("Price: 100")); // null

// è´Ÿå‘åè¡Œæ–­è¨€ ?<!ï¼ˆå‰é¢ä¸æ˜¯...ï¼‰
const notPrecededBy = /(?<!\$)\d+/;
console.log(notPrecededBy.exec("Price: $100")); // null
console.log(notPrecededBy.exec("Price: 100")); // ["100"]

// å®ç”¨æ–­è¨€ç¤ºä¾‹
// åŒ¹é…ä¸åœ¨å¼•å·å†…çš„å•è¯
const notInQuotes = /(?<!["'])\bword\b(?!["'])/;
// åŒ¹é…ç‹¬ç«‹çš„æ•°å­—ï¼ˆä¸æ˜¯å…¶ä»–æ•°å­—çš„ä¸€éƒ¨åˆ†ï¼‰
const standaloneNumber = /(?<!\d)\d+(?!\d)/;
```

## æ­£åˆ™è¡¨è¾¾å¼æ–¹æ³•

### 1. RegExp å¯¹è±¡æ–¹æ³•

```js
const regex = /test/gi;

// test() - æµ‹è¯•æ˜¯å¦åŒ¹é…
console.log(regex.test("test Test TEST")); // true

// exec() - æ‰§è¡ŒåŒ¹é…ï¼Œè¿”å›è¯¦ç»†ä¿¡æ¯
regex.lastIndex = 0; // é‡ç½®ä½ç½®
console.log(regex.exec("test Test TEST"));
// ["test", index: 0, input: "test Test TEST", groups: undefined]

regex.lastIndex = 0;
const result = regex.exec("test Test TEST");
console.log(result[0]); // åŒ¹é…çš„æ–‡æœ¬
console.log(result.index); // åŒ¹é…å¼€å§‹çš„ä½ç½®
console.log(result.input); // åŸå§‹å­—ç¬¦ä¸²

// toString() - è¿”å›æ­£åˆ™è¡¨è¾¾å¼å­—ç¬¦ä¸²
console.log(regex.toString()); // "/test/gi"

// source - è·å–æ­£åˆ™è¡¨è¾¾å¼æºç ï¼ˆä¸å«æ ‡å¿—ï¼‰
console.log(regex.source); // "test"

// flags - è·å–æ ‡å¿—å­—ç¬¦ä¸²
console.log(regex.flags); // "gi"

// lastIndex - ä¸‹æ¬¡åŒ¹é…å¼€å§‹çš„ä½ç½®ï¼ˆä»…å¯¹gæˆ–yæ ‡å¿—æœ‰æ•ˆï¼‰
const globalRegex = /a/g;
globalRegex.test("abc");
console.log(globalRegex.lastIndex); // 1
globalRegex.test("abc");
console.log(globalRegex.lastIndex); // 2
```

### 2. String å¯¹è±¡æ–¹æ³•

```js
const str = "Hello World! Hello JavaScript!";

// match() - è¿”å›åŒ¹é…ç»“æœ
console.log(str.match(/hello/gi)); // ["Hello", "Hello"]
console.log(str.match(/hello/i)); // ["Hello"]ï¼ˆç¬¬ä¸€ä¸ªåŒ¹é…ï¼‰

// matchAll() - è¿”å›æ‰€æœ‰åŒ¹é…çš„è¿­ä»£å™¨ï¼ˆES2020+ï¼‰
const matches = str.matchAll(/hello/gi);
for (const match of matches) {
    console.log(match[0], match.index);
}
// "Hello" 0
// "Hello" 13

// search() - è¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…çš„ä½ç½®
console.log(str.search(/world/i)); // 6
console.log(str.search(/notfound/)); // -1

// replace() - æ›¿æ¢åŒ¹é…çš„æ–‡æœ¬
console.log(str.replace(/hello/gi, "Hi")); // "Hi World! Hi JavaScript!"

// replace() ä½¿ç”¨å‡½æ•°
console.log(
    str.replace(/hello/gi, (match, offset) => {
        return match.toUpperCase() + `(${offset})`;
    })
); // "HELLO(0) World! HELLO(13) JavaScript!"

// split() - ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†å‰²å­—ç¬¦ä¸²
console.log("a,b, c, d".split(/\s*,\s*/)); // ["a", "b", "c", "d"]
console.log("hello world".split(/\s+/)); // ["hello", "world"]

// split() ä½¿ç”¨åˆ†ç»„ï¼ˆåŒ…å«åˆ†éš”ç¬¦ï¼‰
console.log("hello world".split(/(\s+)/)); // ["hello", " ", "world"]
```

## é«˜çº§æ¨¡å¼ä¸åº”ç”¨

### 1. å¸¸ç”¨æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼

```js
// é‚®ç®±éªŒè¯
const email = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
console.log(email.test("test@example.com")); // true
console.log(email.test("test@example.co.uk")); // true
console.log(email.test("test@example")); // false

// æ‰‹æœºå·ç ï¼ˆä¸­å›½ï¼‰
const mobileCN = /^(?:(?:\+|00)86)?1[3-9]\d{9}$/;
console.log(mobileCN.test("13800138000")); // true
console.log(mobileCN.test("+8613800138000")); // true
console.log(mobileCN.test("12800138000")); // false

// URLéªŒè¯
const url = /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([\/\w .-]*)*\/?$/;
console.log(url.test("https://www.example.com")); // true
console.log(url.test("http://example.com/path")); // true

// èº«ä»½è¯å·ç ï¼ˆä¸­å›½ï¼‰
const idCard = /^[1-9]\d{5}(?:18|19|20)\d{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[12]\d|3[01])\d{3}[\dX]$/;
console.log(idCard.test("110101199003075678")); // true

// å¯†ç å¼ºåº¦éªŒè¯
const strongPassword = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
console.log(strongPassword.test("Password123!")); // true

// IPv4åœ°å€
const ipv4 = /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/;
console.log(ipv4.test("192.168.1.1")); // true

// ä¸­æ–‡å§“å
const chineseName = /^[\u4e00-\u9fa5]{2,4}$/;
console.log(chineseName.test("å¼ ä¸‰")); // true
console.log(chineseName.test("æå°é¾™")); // true

// æ—¥æœŸæ ¼å¼ï¼ˆYYYY-MM-DDï¼‰
const dateFormat = /^\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\d|3[01])$/;
console.log(dateFormat.test("2024-01-15")); // true
console.log(dateFormat.test("2024-1-15")); // false

// æå–HTMLæ ‡ç­¾å†…å®¹
const htmlTag = /<([a-z]+)(?:\s+[^>]*)?>([^<]*)<\/\1>/i;
const html = '<div class="test">Hello World</div>';
const tagMatch = html.match(htmlTag);
console.log(tagMatch[2]); // "Hello World"
```

### 2. éªŒè¯ä¸æå–å·¥å…·

```js
// éªŒè¯å·¥å…·å‡½æ•°
const Validator = {
    // é‚®ç®±éªŒè¯
    isEmail(email) {
        return /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(email);
    },

    // æ‰‹æœºå·éªŒè¯
    isMobile(mobile, country = "CN") {
        const patterns = {
            CN: /^(?:(?:\+|00)86)?1[3-9]\d{9}$/,
            US: /^\+1\d{10}$/,
            UK: /^\+44\d{10}$/,
        };
        return patterns[country]?.test(mobile) || false;
    },

    // URLéªŒè¯
    isURL(url) {
        try {
            new URL(url);
            return true;
        } catch {
            return /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([\/\w .-]*)*\/?$/.test(url);
        }
    },

    // èº«ä»½è¯éªŒè¯
    isIDCard(id, country = "CN") {
        if (country === "CN") {
            if (
                !/^[1-9]\d{5}(?:18|19|20)\d{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[12]\d|3[01])\d{3}[\dX]$/.test(
                    id
                )
            ) {
                return false;
            }

            // æ ¡éªŒç éªŒè¯ï¼ˆç®€åŒ–ç‰ˆï¼‰
            const weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
            const checkCodes = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];

            let sum = 0;
            for (let i = 0; i < 17; i++) {
                sum += parseInt(id[i]) * weights[i];
            }

            const checkCode = checkCodes[sum % 11];
            return id[17].toUpperCase() === checkCode;
        }
        return false;
    },

    // å¯†ç å¼ºåº¦æ£€æŸ¥
    checkPasswordStrength(password) {
        const checks = {
            length: password.length >= 8,
            lowercase: /[a-z]/.test(password),
            uppercase: /[A-Z]/.test(password),
            number: /\d/.test(password),
            special: /[@$!%*?&]/.test(password),
        };

        const score = Object.values(checks).filter(Boolean).length;

        return {
            score,
            level: score >= 4 ? "strong" : score >= 3 ? "medium" : "weak",
            checks,
        };
    },
};

// æå–å·¥å…·å‡½æ•°
const Extractor = {
    // æå–æ‰€æœ‰é‚®ç®±
    extractEmails(text) {
        const pattern = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
        return text.match(pattern) || [];
    },

    // æå–æ‰€æœ‰URL
    extractURLs(text) {
        const pattern = /https?:\/\/[^\s/$.?#].[^\s]*/g;
        return text.match(pattern) || [];
    },

    // æå–æ‰€æœ‰ç”µè¯å·ç 
    extractPhoneNumbers(text, country = "CN") {
        const patterns = {
            CN: /(?:(?:\+|00)86)?1[3-9]\d{9}/g,
            US: /\+1\d{10}/g,
        };
        return text.match(patterns[country]) || [];
    },

    // æå–JSONå¯¹è±¡
    extractJSON(text) {
        const pattern = /\{(?:[^{}]|(?:\{[^{}]*\}))*\}/g;
        const matches = text.match(pattern) || [];

        return matches
            .map(match => {
                try {
                    return JSON.parse(match);
                } catch {
                    return null;
                }
            })
            .filter(Boolean);
    },

    // æå–ä¸­æ–‡å­—ç¬¦
    extractChinese(text) {
        const pattern = /[\u4e00-\u9fff]+/g;
        return text.match(pattern) || [];
    },

    // æå–å“ˆå¸Œæ ‡ç­¾
    extractHashtags(text) {
        const pattern = /#[\w\u4e00-\u9fff]+/g;
        return text.match(pattern) || [];
    },

    // æå–@æåŠ
    extractMentions(text) {
        const pattern = /@[\w\u4e00-\u9fff]+/g;
        return text.match(pattern) || [];
    },
};

// ä½¿ç”¨ç¤ºä¾‹
console.log(Validator.isEmail("test@example.com")); // true
console.log(Validator.checkPasswordStrength("Password123!"));
console.log(Extractor.extractEmails("Contact: test@example.com, support@test.com"));
```

### 3. æ–‡æœ¬å¤„ç†ä¸æ¸…æ´—

```js
// æ–‡æœ¬å¤„ç†å·¥å…·
const TextProcessor = {
    // ç§»é™¤HTMLæ ‡ç­¾
    stripHTML(html) {
        return html.replace(/<[^>]*>/g, "");
    },

    // ç§»é™¤å¤šä½™ç©ºç™½
    normalizeWhitespace(text) {
        return text.replace(/\s+/g, " ").trim();
    },

    // ç§»é™¤æ ‡ç‚¹ç¬¦å·
    removePunctuation(text) {
        return text.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "");
    },

    // æå–çº¯æ–‡æœ¬ï¼ˆç§»é™¤æ‰€æœ‰éå­—æ¯æ•°å­—å’Œä¸­æ–‡ï¼‰
    extractPlainText(text) {
        return text.replace(/[^\w\u4e00-\u9fff\s]/g, "");
    },

    // å•è¯è®¡æ•°
    wordCount(text) {
        const words = text.match(/\b[\w\u4e00-\u9fff]+\b/g) || [];
        return words.length;
    },

    // å¥å­åˆ†å‰²
    splitSentences(text) {
        return text.split(/[.!?]+/).filter(s => s.trim());
    },

    // é¦–å­—æ¯å¤§å†™
    toTitleCase(text) {
        return text.toLowerCase().replace(/\b\w/g, char => char.toUpperCase());
    },

    // é©¼å³°è½¬ä¸‹åˆ’çº¿
    camelToSnake(camelCase) {
        return camelCase.replace(/[A-Z]/g, match => "_" + match.toLowerCase());
    },

    // ä¸‹åˆ’çº¿è½¬é©¼å³°
    snakeToCamel(snakeCase) {
        return snakeCase.replace(/_([a-z])/g, (_, char) => char.toUpperCase());
    },

    // æˆªæ–­æ–‡æœ¬å¹¶æ·»åŠ çœç•¥å·
    truncate(text, maxLength, suffix = "...") {
        if (text.length <= maxLength) return text;
        return text.substr(0, maxLength - suffix.length).replace(/\s+\S*$/, "") + suffix;
    },

    // ç”Ÿæˆæ‘˜è¦ï¼ˆæå–å‰Nä¸ªå¥å­ï¼‰
    generateSummary(text, sentenceCount = 2) {
        const sentences = this.splitSentences(text);
        return sentences.slice(0, sentenceCount).join(". ") + ".";
    },

    // æŸ¥æ‰¾å’Œæ›¿æ¢ï¼ˆæ”¯æŒæ­£åˆ™è¡¨è¾¾å¼ï¼‰
    findAndReplace(text, find, replace) {
        const regex = new RegExp(find, "gi");
        return text.replace(regex, replace);
    },

    // é«˜äº®å…³é”®è¯
    highlightKeywords(text, keywords) {
        const escapedKeywords = keywords.map(k => k.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
        const pattern = new RegExp(`(${escapedKeywords.join("|")})`, "gi");
        return text.replace(pattern, "<mark>$1</mark>");
    },
};

// ä½¿ç”¨ç¤ºä¾‹
const html = "<div><h1>æ ‡é¢˜</h1><p>è¿™æ˜¯ä¸€æ®µæ–‡æœ¬ã€‚</p></div>";
console.log(TextProcessor.stripHTML(html)); // "æ ‡é¢˜è¿™æ˜¯ä¸€æ®µæ–‡æœ¬ã€‚"
console.log(TextProcessor.wordCount("Hello World ä½ å¥½ä¸–ç•Œ")); // 4
```

## æ€§èƒ½ä¼˜åŒ–

### 1. ç¼–è¯‘ä¸ç¼“å­˜

```js
// 1. ç¼“å­˜æ­£åˆ™è¡¨è¾¾å¼
const regexCache = new Map();

function getCachedRegex(pattern, flags) {
    const key = pattern + "|" + flags;
    if (!regexCache.has(key)) {
        regexCache.set(key, new RegExp(pattern, flags));
    }
    return regexCache.get(key);
}

// ä½¿ç”¨ç¼“å­˜çš„regex
const emailRegex = getCachedRegex("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$");
console.log(emailRegex.test("test@example.com"));

// 2. é¢„ç¼–è¯‘å¸¸ç”¨æ­£åˆ™è¡¨è¾¾å¼
const CommonRegex = {
    EMAIL: /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/,
    URL: /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([\/\w .-]*)*\/?$/,
    PHONE: /^(?:(?:\+|00)86)?1[3-9]\d{9}$/,
    ID_CARD: /^[1-9]\d{5}(?:18|19|20)\d{2}(?:0[1-9]|1[0-2])(?:0[1-9]|[12]\d|3[01])\d{3}[\dX]$/,
    CHINESE: /[\u4e00-\u9fff]/,
    DIGITS: /\d+/g,
    WHITESPACE: /\s+/g,
};

// 3. ä½¿ç”¨å­—é¢é‡è€Œéæ„é€ å‡½æ•°ï¼ˆæ€§èƒ½æ›´å¥½ï¼‰
// å¥½
const goodRegex = /\d+/g;
// ä¸å¥½ï¼ˆæ¯æ¬¡éƒ½ä¼šç¼–è¯‘ï¼‰
const badRegex = new RegExp("\\d+", "g");
```

### 2. ä¼˜åŒ–æŠ€å·§

```js
// 1. é¿å…å›æº¯çˆ†ç‚¸
// ä¸å¥½ï¼šå¯èƒ½å¯¼è‡´ç¾éš¾æ€§å›æº¯
const badRegex = /(a+)+b/;
// å¥½ï¼šä½¿ç”¨åŸå­ç»„ï¼ˆJavaScriptä¸æ”¯æŒï¼‰æˆ–ä¿®æ”¹æ¨¡å¼
const goodRegex = /a+b/;

// 2. ä½¿ç”¨å…·ä½“å­—ç¬¦ç±»è€Œéé€šç”¨å­—ç¬¦
// ä¸å¥½
const slow = /.*@.*\..*/;
// å¥½
const fast = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

// 3. ä½¿ç”¨é”šç‚¹åŠ é€Ÿ
// ä¸å¥½
const noAnchor = /\d{4}-\d{2}-\d{2}/;
// å¥½
const withAnchor = /^\d{4}-\d{2}-\d{2}$/;

// 4. å‡å°‘æ•è·åˆ†ç»„
// ä¸å¥½ï¼šä¸å¿…è¦çš„æ•è·
const withCapture = /(\d{4})-(\d{2})-(\d{2})/;
// å¥½ï¼šä½¿ç”¨éæ•è·åˆ†ç»„æˆ–å‘½ååˆ†ç»„
const withoutCapture = /(?:\d{4})-(?:\d{2})-(?:\d{2})/;
const namedGroups = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

// 5. é¿å…é‡å¤ç¼–è¯‘
function processText(text, pattern) {
    // ä¸å¥½ï¼šæ¯æ¬¡è°ƒç”¨éƒ½ç¼–è¯‘
    const regex = new RegExp(pattern, "g");
    return text.match(regex);
}

function createProcessor(pattern) {
    // å¥½ï¼šåªç¼–è¯‘ä¸€æ¬¡
    const regex = new RegExp(pattern, "g");
    return text => text.match(regex);
}

const emailProcessor = createProcessor("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}");

// 6. ä½¿ç”¨test()è€Œéexec()è¿›è¡Œå­˜åœ¨æ€§æ£€æŸ¥
// å¥½ï¼šåªéœ€è¦æ£€æŸ¥æ˜¯å¦å­˜åœ¨
if (/\d+/.test(text)) {
    // å¤„ç†
}

// ä¸å¥½ï¼šè·å–ä¸éœ€è¦çš„è¯¦ç»†ä¿¡æ¯
const match = /\d+/.exec(text);
if (match) {
    // å¤„ç†
}
```

### 3. æ€§èƒ½æµ‹è¯•

```js
// æ­£åˆ™è¡¨è¾¾å¼æ€§èƒ½æµ‹è¯•å·¥å…·
function benchmarkRegex(name, regex, testString, iterations = 10000) {
    const start = performance.now();

    for (let i = 0; i < iterations; i++) {
        regex.test(testString);
    }

    const end = performance.now();
    const duration = end - start;

    console.log(`${name}: ${duration.toFixed(2)}ms (${(duration / iterations).toFixed(4)}ms/op)`);

    return duration;
}

// æµ‹è¯•ä¸åŒæ¨¡å¼
const testString = "test@example.com";

// è´ªå©ª vs æƒ°æ€§
benchmarkRegex("Greedy", /.*@.*\..*/, testString);
benchmarkRegex("Lazy", /.*?@.*?\..*?/, testString);

// æœ‰æ— é”šç‚¹
benchmarkRegex("No anchor", /\d{4}-\d{2}-\d{2}/, "2024-01-15");
benchmarkRegex("With anchor", /^\d{4}-\d{2}-\d{2}$/, "2024-01-15");

// ç¼“å­˜æ•ˆæœ
const uncachedTime = benchmarkRegex("Uncached", new RegExp("\\d+"), "12345");
const cachedRegex = /\d+/;
const cachedTime = benchmarkRegex("Cached", cachedRegex, "12345");

console.log(
    `Caching improvement: ${(((uncachedTime - cachedTime) / uncachedTime) * 100).toFixed(2)}%`
);
```

## è°ƒè¯•ä¸æµ‹è¯•

### 1. è°ƒè¯•å·¥å…·

```js
// æ­£åˆ™è¡¨è¾¾å¼è°ƒè¯•å™¨
class RegexDebugger {
    constructor(pattern, flags = '') {
        this.regex = new RegExp(pattern, flags);
        this.pattern = pattern;
        this.flags = flags;
        this.matches = [];
    }

    // è¯¦ç»†åŒ¹é…
    debug(text) {
        console.log('=== Regex Debug ===');
        console.log('Pattern:', this.pattern);
        console.log('Flags:', this.flags);
        console.log('Test string:', text);
        console.log('---');

        this.regex.lastIndex = 0;
        let match;
        this.matches = [];

        while ((match = this.regex.exec(text)) !== null) {
            console.log(`Match #${this.matches.length + 1}:`);
            console.log('  Full match:', match[0]);
            console.log('  Index:', match.index);

            if (match.groups) {
                console.log('  Named groups:', match.groups);
            }

            for (let i = 1; i < match.length; i++) {
                if (match[i] !== undefined) {
                    console.log(`  Group ${i}:`, match[i]);
                }
            }

            console.log('---');
            this.matches.push(match);
        }

        if (this.matches.length === 0) {
            console.log('No matches found.');
        }

        return this.matches;
    }

    // å¯è§†åŒ–åˆ†ç»„
    visualizeGroups(text) {
        const match = this.regex.exec(text);
        if (!match) {
            console.log('No match');
            return;
        }

        console.log('Group visualization:');
        console.log('Full match:', match[0]);
        console.log(' ');

        for (let i = 0; i < match[0].length; i++) {
            let groupNum = 0;
            for (let g = 1; g < match.length; g++) {
                if (match[g] && i >= match.index && i < match.index + match[0].length) {
                    // ç®€å•å¯è§†åŒ–åˆ†ç»„
                    console.log(`Position ${i}: "${match[0][i]}"`);
                }
            }
        }
    }

    // æµ‹è¯•å¤šä¸ªå­—ç¬¦ä¸²
    testCases(cases) {
        console.log('=== Test Cases ===');

        cases.forEach((testCase, index) => {
            console.log(`\nTest ${index + 1}: "${testCase}"`);
            const result = this.regex.test(testCase);
            console.log('Result:', result ? 'âœ“ PASS' : 'âœ— FAIL');

            if (result) {
                const match = this.regex.exec(testCase);
                console.log('Match:', match[0]);
                this.regex.lastIndex = 0; // é‡ç½®
            }
        });
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const debugger = new RegexDebugger('(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})');
debugger.debug('Date: 2024-01-15');
debugger.testCases(['2024-01-15', '2024/01/15', 'invalid-date']);
```

### 2. å•å…ƒæµ‹è¯•

```js
// æ­£åˆ™è¡¨è¾¾å¼æµ‹è¯•å¥—ä»¶
class RegexTestSuite {
    constructor() {
        this.tests = [];
    }

    // æ·»åŠ æµ‹è¯•ç”¨ä¾‹
    addTest(name, pattern, testCases) {
        this.tests.push({ name, pattern, testCases });
    }

    // è¿è¡Œæ‰€æœ‰æµ‹è¯•
    runAll() {
        console.log("Running Regex Tests...\n");

        let passed = 0;
        let failed = 0;

        this.tests.forEach((test, index) => {
            console.log(`Test ${index + 1}: ${test.name}`);
            console.log(`Pattern: ${test.pattern}`);

            const regex = new RegExp(test.pattern);
            let testPassed = true;

            test.testCases.forEach(testCase => {
                const result = regex.test(testCase.input);
                const passed = result === testCase.expected;

                if (!passed) {
                    testPassed = false;
                    console.log(`  âœ— FAIL: "${testCase.input}"`);
                    console.log(`    Expected: ${testCase.expected}, Got: ${result}`);
                }

                regex.lastIndex = 0; // é‡ç½®
            });

            if (testPassed) {
                console.log(`  âœ“ PASS (${test.testCases.length} cases)`);
                passed++;
            } else {
                failed++;
            }

            console.log();
        });

        console.log(`\nSummary: ${passed} passed, ${failed} failed`);
        return { passed, failed, total: passed + failed };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const suite = new RegexTestSuite();

// æµ‹è¯•é‚®ç®±æ­£åˆ™
suite.addTest("Email Validation", "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$", [
    { input: "test@example.com", expected: true },
    { input: "test@example.co.uk", expected: true },
    { input: "test@example", expected: false },
    { input: "@example.com", expected: false },
]);

// æµ‹è¯•æ—¥æœŸæ­£åˆ™
suite.addTest("Date Format (YYYY-MM-DD)", "^\\d{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[12]\\d|3[01])$", [
    { input: "2024-01-15", expected: true },
    { input: "2024-1-15", expected: false },
    { input: "2024-13-01", expected: false },
    { input: "2024-01-32", expected: false },
]);

// è¿è¡Œæµ‹è¯•
suite.runAll();
```

## é«˜çº§æŠ€å·§ä¸æ¨¡å¼

### 1. é€’å½’åŒ¹é…

```js
// åŒ¹é…åµŒå¥—ç»“æ„ï¼ˆå¦‚æ‹¬å·ï¼‰
function matchNestedPairs(text, open = "(", close = ")") {
    const regex = new RegExp(
        `\\${open}(?:(?!\\${open}|\\${close}).|\\${open}(?<depth>)|\\)(?<-depth>))*(?(depth)(?!))\\${close}`,
        "g"
    );
    const matches = [];
    let match;

    while ((match = regex.exec(text)) !== null) {
        matches.push(match[0]);
    }

    return matches;
}

// ä½¿ç”¨å¹³è¡¡ç»„ï¼ˆéœ€è¦é€’å½’æ¨¡å¼æ”¯æŒï¼ŒJavaScriptæœ‰é™æ”¯æŒï¼‰
const nestedParentheses = /\((?:[^()]|(?R))*\)/;

// æ›¿ä»£æ–¹æ¡ˆï¼šä½¿ç”¨å‡½æ•°é€’å½’å¤„ç†
function extractNested(text, open = "(", close = ")") {
    const result = [];
    let depth = 0;
    let current = "";
    let startIndex = -1;

    for (let i = 0; i < text.length; i++) {
        const char = text[i];

        if (char === open) {
            if (depth === 0) {
                startIndex = i;
            }
            depth++;
        }

        if (depth > 0) {
            current += char;
        }

        if (char === close) {
            depth--;
            if (depth === 0) {
                result.push({
                    text: current,
                    start: startIndex,
                    end: i,
                });
                current = "";
            }
        }
    }

    return result;
}

// ç¤ºä¾‹
console.log(extractNested("a(b(c)d)e(f)g"));
```

### 2. å¤æ‚éªŒè¯

```js
// ä¿¡ç”¨å¡éªŒè¯
function validateCreditCard(cardNumber) {
    // ç§»é™¤ç©ºæ ¼å’Œç ´æŠ˜å·
    const cleaned = cardNumber.replace(/[\s-]/g, "");

    // æ£€æŸ¥åŸºæœ¬æ ¼å¼
    if (!/^\d{13,19}$/.test(cleaned)) {
        return { valid: false, reason: "Invalid length" };
    }

    // Luhnç®—æ³•æ ¡éªŒ
    let sum = 0;
    let isSecond = false;

    for (let i = cleaned.length - 1; i >= 0; i--) {
        let digit = parseInt(cleaned[i]);

        if (isSecond) {
            digit *= 2;
            if (digit > 9) {
                digit -= 9;
            }
        }

        sum += digit;
        isSecond = !isSecond;
    }

    const luhnValid = sum % 10 === 0;

    // å¡ç±»å‹è¯†åˆ«
    const cardTypes = {
        Visa: /^4[0-9]{12}(?:[0-9]{3})?$/,
        Mastercard: /^5[1-5][0-9]{14}$/,
        "American Express": /^3[47][0-9]{13}$/,
        Discover: /^6(?:011|5[0-9]{2})[0-9]{12}$/,
        UnionPay: /^62[0-9]{14,17}$/,
    };

    let cardType = "Unknown";
    for (const [type, pattern] of Object.entries(cardTypes)) {
        if (pattern.test(cleaned)) {
            cardType = type;
            break;
        }
    }

    return {
        valid: luhnValid,
        cardType,
        formatted: cleaned.replace(/(\d{4})(?=\d)/g, "$1 "),
        luhnValid,
    };
}

// ä½¿ç”¨ç¤ºä¾‹
console.log(validateCreditCard("4111 1111 1111 1111"));
```

### 3. æ¨¡æ¿å¼•æ“å®ç°

```js
// ç®€å•çš„æ¨¡æ¿å¼•æ“
class TemplateEngine {
    constructor(template) {
        this.template = template;
        this.variables = {};
    }

    // è®¾ç½®å˜é‡
    set(name, value) {
        this.variables[name] = value;
        return this;
    }

    // æ¸²æŸ“æ¨¡æ¿
    render() {
        let result = this.template;

        // æ›¿æ¢å˜é‡ {{variable}}
        result = result.replace(/\{\{(\w+)\}\}/g, (match, name) => {
            return this.variables[name] !== undefined ? this.variables[name] : match;
        });

        // å¤„ç†æ¡ä»¶è¯­å¥ {% if condition %}...{% endif %}
        result = result.replace(
            /\{%\s*if\s+(\w+)\s*%\}(.*?)\{%\s*endif\s*%\}/gs,
            (match, condition, content) => {
                return this.variables[condition] ? content : "";
            }
        );

        // å¤„ç†å¾ªç¯ {% for item in items %}...{% endfor %}
        result = result.replace(
            /\{%\s*for\s+(\w+)\s+in\s+(\w+)\s*%\}(.*?)\{%\s*endfor\s*%\}/gs,
            (match, itemName, arrayName, content) => {
                const items = this.variables[arrayName] || [];
                return items
                    .map(item => {
                        const itemContext = { ...this.variables, [itemName]: item };
                        return content.replace(/\{\{(\w+)\}\}/g, (match, name) => {
                            return itemContext[name] !== undefined ? itemContext[name] : match;
                        });
                    })
                    .join("");
            }
        );

        return result;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const template = `
Hello {{name}}!

{% if showDetails %}
Details:
{% for item in items %}
  - {{item}}
{% endfor %}
{% endif %}
`;

const engine = new TemplateEngine(template);
engine.set("name", "John").set("showDetails", true).set("items", ["Item 1", "Item 2", "Item 3"]);

console.log(engine.render());
```
